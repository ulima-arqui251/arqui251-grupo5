# 0.9. Trabajo Individual - Patrones Cloud (Informes y Videos)

# Manuel Malpartida - Retry

# El PatrÃ³n Retry: Resiliencia en Sistemas de E-Commerce

## IntroducciÃ³n
El patrÃ³n Retry es un mecanismo de tolerancia a fallos diseÃ±ado para manejar errores transitorios en sistemas distribuidos. En el contexto de e-commerce, donde la disponibilidad y experiencia del usuario son crÃ­ticas, este patrÃ³n permite recuperarse automÃ¡ticamente de fallas temporales en servicios externos como pasarelas de pago, APIs de inventario o sistemas de recomendaciÃ³n.

## Â¿QuÃ© es el PatrÃ³n Retry?
El patrÃ³n Retry actÃºa como un sistema de recuperaciÃ³n automÃ¡tica que:

- Detecta fallas temporales (timeouts, errores HTTP 5xx)
- Reintenta la operaciÃ³n fallida siguiendo una polÃ­tica configurable
- Implementa tiempos de espera entre reintentos (backoff)
- Finaliza cuando tiene Ã©xito o alcanza el lÃ­mite de intentos

**Ejemplo en e-commerce**:

 - Cliente â†’ [Intento de pago â†’ Falla temporal â†’ Espera 1s â†’ Reintento â†’ Ã‰xito]



## Problema que Resuelve en E-Commerce
**DesafÃ­os comunes**:
- Pagos fallidos: 15-20% de transacciones fallan inicialmente por inestabilidad en APIs de pago
- Disponibilidad de inventario: Contenciones en bases de datos durante ofertas flash
- Recomendaciones: Latencia variable en servicios de ML
- Notificaciones: Fallos en envÃ­o de emails/notificaciones push

**Consecuencias sin Retry**:
- PÃ©rdida de ventas por fallas evitables
- Mala experiencia de usuario (errores visibles)
- Inconsistencias en datos crÃ­ticos

## Arquitectura del PatrÃ³n
**Componentes clave**:
1. **Detector de fallas transitorias**: Clasifica errores como recuperables
2. **PolÃ­tica de reintentos**: Define mÃ¡ximo de intentos y tiempos de espera
3. **Estrategia de backoff**: Calcula intervalos entre reintentos (ej: exponencial)
4. **Mecanismo de fallback**: AcciÃ³n alternativa cuando se agotan los reintentos

**Flujo tÃ­pico**:
1. OperaciÃ³n falla por error transitorio
2. Sistema espera un intervalo calculado
3. Reintenta la operaciÃ³n
4. Repite hasta Ã©xito o lÃ­mite de intentos

## ImplementaciÃ³n en E-Commerce
**TecnologÃ­as recomendadas**:
- Node.js: `async-retry`, `promise-retry`
- Java: Spring Retry, Resilience4j
- .NET: Polly
- Python: Tenacity

### Ejemplo prÃ¡ctico (Servicio de Pagos)
```javascript
const retry = require('async-retry');

// Simulador de servicio de pagos con fallas controladas
let attemptCount = 0;
const mockPaymentGateway = {
  charge: async (paymentData) => {
    attemptCount++;
    console.log(`ğŸ”µ Intento #${attemptCount} - Procesando pago $${paymentData.amount}`);
    
    // Simulamos fallas temporales en los primeros 2 intentos
    if (attemptCount < 3) {
      throw new Error('Error temporal: Servicio de pagos no disponible');
    }
    
    return { success: true, transactionId: `txn_${Date.now()}` };
  }
};

// ImplementaciÃ³n con patrÃ³n Retry
async function processPayment(paymentData) {
  try {
    return await retry(
      async (bail) => {
        try {
          return await mockPaymentGateway.charge(paymentData);
        } catch (error) {
          if (error.message.includes('temporal')) {
            console.log(`ğŸŸ¡ ${error.message} - Reintentando...`);
            throw error;
          }
          bail(error);
          return;
        }
      },
      {
        retries: 3,
        minTimeout: 1000,
        factor: 2,
        onRetry: (error) => {
          console.log(`â³ Esperando ${error.attemptNumber * 1}s...`);
        }
      }
    );
  } catch (error) {
    console.error(`ğŸ”´ Error final: ${error.message}`);
    return { success: false };
  }
}

// EjecuciÃ³n de prueba
(async () => {
  console.log('=== DEMO PATRÃ“N RETRY EN E-COMMERCE ===');
  const result = await processPayment({ amount: 99.99 });
  console.log('Resultado final:', result);
})();


=== DEMO PATRÃ“N RETRY EN E-COMMERCE ===
ğŸ”µ Intento #1 - Procesando pago $99.99
ğŸŸ¡ Error temporal: Servicio de pagos no disponible - Reintentando...
â³ Esperando 1s...
ğŸ”µ Intento #2 - Procesando pago $99.99
ğŸŸ¡ Error temporal: Servicio de pagos no disponible - Reintentando...
â³ Esperando 2s...
ğŸ”µ Intento #3 - Procesando pago $99.99
Resultado final: { success: true, transactionId: 'txn_1634567890123' }

```

# Casos de Uso en E-Commerce

## Procesamiento de pagos:
- Reintentos cuando fallan conexiones con Stripe/PayPal.
- Backoff exponencial para evitar saturar el servicio.

## Reserva de inventario:
- Reintentos ante errores de concurrencia.
- Jitter para distribuir la carga.

## Sistema de recomendaciones:
- Reintentos con degradaciÃ³n elegante (muestra resultados en cachÃ© primero).

## Notificaciones:
- Reintentos para enviar emails/notificaciones push.
- Encolamiento como fallback.

# Ventajas y Consideraciones

## Beneficios:
âœ“ Mayor tasa de Ã©xito en transacciones.  
âœ“ Mejor experiencia de usuario (menos errores visibles).  
âœ“ Resiliencia automÃ¡tica ante fallas temporales.  

## Riesgos:
âœ— Puede enmascarar problemas subyacentes si no se monitorea.  
âœ— Posible saturaciÃ³n si no se configura adecuadamente.  
âœ— No aplicable a operaciones no idempotentes.  

# Mejores PrÃ¡cticas
- Configurar lÃ­mites razonables (3-5 reintentos).
- Usar backoff exponencial + jitter para evitar sincronizaciÃ³n.
- Implementar circuit breakers para fallas prolongadas.
- Monitorear mÃ©tricas de reintentos (indicador de problemas).
- Evitar en operaciones no idempotentes (ej: POST que crean recursos).

# ConclusiÃ³n
En sistemas de e-commerce, el patrÃ³n Retry es esencial para manejar la inevitable inestabilidad de servicios distribuidos. Cuando se implementa correctamente, puede reducir fallas visibles al usuario en mÃ¡s del 50%, mejorando significativamente la experiencia de compra y las mÃ©tricas de conversiÃ³n.
