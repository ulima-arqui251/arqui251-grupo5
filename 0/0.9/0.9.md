# 0.9. Trabajo Individual - Patrones Cloud (Informes y Videos)

## Manuel Malpartida - Retry

# El PatrÃ³n Retry En Sistemas de E-Commerce

## IntroducciÃ³n
El patrÃ³n Retry es un mecanismo de tolerancia a fallos diseÃ±ado para manejar errores transitorios en sistemas distribuidos. En el contexto de e-commerce, donde la disponibilidad y experiencia del usuario son crÃ­ticas, este patrÃ³n permite recuperarse automÃ¡ticamente de fallas temporales en servicios externos como pasarelas de pago, APIs de inventario o sistemas de recomendaciÃ³n.

## Â¿QuÃ© es el PatrÃ³n Retry?
El patrÃ³n Retry actÃºa como un sistema de recuperaciÃ³n automÃ¡tica que:

- Detecta fallas temporales (timeouts, errores HTTP 5xx)
- Reintenta la operaciÃ³n fallida siguiendo una polÃ­tica configurable
- Implementa tiempos de espera entre reintentos (backoff)
- Finaliza cuando tiene Ã©xito o alcanza el lÃ­mite de intentos

**Ejemplo en e-commerce**:

- Cliente â†’ [Intento de pago â†’ Falla temporal â†’ Espera 1s â†’ Reintento â†’ Ã‰xito]

## Problema que Resuelve en E-Commerce
**DesafÃ­os comunes**:
- Pagos fallidos: 15-20% de transacciones fallan inicialmente por inestabilidad en APIs de pago
- Disponibilidad de inventario: Contenciones en bases de datos durante ofertas flash
- Recomendaciones: Latencia variable en servicios de ML
- Notificaciones: Fallos en envÃ­o de emails/notificaciones push

**Consecuencias sin Retry**:
- PÃ©rdida de ventas por fallas evitables
- Mala experiencia de usuario (errores visibles)
- Inconsistencias en datos crÃ­ticos

## Arquitectura del PatrÃ³n
**Componentes clave**:
1. **Detector de fallas transitorias**: Clasifica errores como recuperables
2. **PolÃ­tica de reintentos**: Define mÃ¡ximo de intentos y tiempos de espera
3. **Estrategia de backoff**: Calcula intervalos entre reintentos (ej: exponencial)
4. **Mecanismo de fallback**: AcciÃ³n alternativa cuando se agotan los reintentos

**Flujo tÃ­pico**:
1. OperaciÃ³n falla por error transitorio
2. Sistema espera un intervalo calculado
3. Reintenta la operaciÃ³n
4. Repite hasta Ã©xito o lÃ­mite de intentos

## ImplementaciÃ³n en E-Commerce
**TecnologÃ­as recomendadas**:
- Node.js: `async-retry`, `promise-retry`
- Java: Spring Retry, Resilience4j
- .NET: Polly
- Python: Tenacity

### Ejemplo prÃ¡ctico (Servicio de Pagos)
```javascript
const retry = require('async-retry');

// Simulador de servicio de pagos con fallas controladas
let attemptCount = 0;
const mockPaymentGateway = {
  charge: async (paymentData) => {
    attemptCount++;
    console.log(`ğŸ”µ Intento #${attemptCount} - Procesando pago $${paymentData.amount}`);
    
    // Simulamos fallas temporales en los primeros 2 intentos
    if (attemptCount < 3) {
      throw new Error('Error temporal: Servicio de pagos no disponible');
    }
    
    return { success: true, transactionId: `txn_${Date.now()}` };
  }
};

// ImplementaciÃ³n con patrÃ³n Retry
async function processPayment(paymentData) {
  try {
    return await retry(
      async (bail) => {
        try {
          return await mockPaymentGateway.charge(paymentData);
        } catch (error) {
          if (error.message.includes('temporal')) {
            console.log(`ğŸŸ¡ ${error.message} - Reintentando...`);
            throw error;
          }
          bail(error);
          return;
        }
      },
      {
        retries: 3,
        minTimeout: 1000,
        factor: 2,
        onRetry: (error) => {
          console.log(`â³ Esperando ${error.attemptNumber * 1}s...`);
        }
      }
    );
  } catch (error) {
    console.error(`ğŸ”´ Error final: ${error.message}`);
    return { success: false };
  }
}

// EjecuciÃ³n de prueba
(async () => {
  console.log('=== DEMO PATRÃ“N RETRY EN E-COMMERCE ===');
  const result = await processPayment({ amount: 99.99 });
  console.log('Resultado final:', result);
})();
 
```

## Casos de Uso en E-Commerce

### Procesamiento de pagos:
- Reintentos cuando fallan conexiones con Stripe/PayPal.
- Backoff exponencial para evitar saturar el servicio.

### Reserva de inventario:
- Reintentos ante errores de concurrencia.
- Jitter para distribuir la carga.

### Sistema de recomendaciones:
- Reintentos con degradaciÃ³n elegante (muestra resultados en cachÃ© primero).

### Notificaciones:
- Reintentos para enviar emails/notificaciones push.
- Encolamiento como fallback.

## Ventajas y Consideraciones

### Beneficios:
âœ“ Mayor tasa de Ã©xito en transacciones.  
âœ“ Mejor experiencia de usuario (menos errores visibles).  
âœ“ Resiliencia automÃ¡tica ante fallas temporales.  

### Riesgos:
âœ— Puede enmascarar problemas subyacentes si no se monitorea.  
âœ— Posible saturaciÃ³n si no se configura adecuadamente.  
âœ— No aplicable a operaciones no idempotentes.  

## Mejores PrÃ¡cticas
- Configurar lÃ­mites razonables (3-5 reintentos).
- Usar backoff exponencial + jitter para evitar sincronizaciÃ³n.
- Implementar circuit breakers para fallas prolongadas.
- Monitorear mÃ©tricas de reintentos (indicador de problemas).
- Evitar en operaciones no idempotentes (ej: POST que crean recursos).

## ConclusiÃ³n
En sistemas de e-commerce, el patrÃ³n Retry es esencial para manejar la inevitable inestabilidad de servicios distribuidos. Cuando se implementa correctamente, puede reducir fallas visibles al usuario en mÃ¡s del 50%, mejorando significativamente la experiencia de compra y las mÃ©tricas de conversiÃ³n.

# Video:

link: https://youtu.be/NrjG9d0cYWw 

## Integrante 2




## ğŸ“Œ 1.  ElecciÃ³n de Tema:

# ğŸ§  ImplementaciÃ³n del PatrÃ³n Cloud â€“ Convoy Secuencial

## ğŸ“Œ 2.  Desarrollo del PatrÃ³n:


## Problema que resuelve el patrÃ³n Convoy Secuencial

En sistemas distribuidos, especialmente aquellos que procesan mensajes en paralelo, surge un problema cuando:

- Se deben procesar mensajes **en orden por grupo** (ej. por cliente o por cuenta).
- El procesamiento de un grupo **bloquea a otros** si se hace secuencialmente.

### â— Ejemplos de problemas:

- Inconsistencias por procesar transacciones fuera de orden.
- Cuellos de botella si un proceso lento detiene todo el flujo.
- Ineficiencia al aplicar bloqueo global en lugar de por grupo.

---

## âœ… SoluciÃ³n que propone el patrÃ³n

El patrÃ³n **Sequential Convoy** permite procesar mensajes relacionados **en orden dentro de su grupo**, pero **sin bloquear otros grupos**. Se basa en:

- AgrupaciÃ³n por claves (por ejemplo, `user_id`, `tenant_id`, `account_id`).
- Particionado de colas o tÃ³picos por clave.
- Procesamiento concurrente entre grupos, pero ordenado dentro de cada uno.

### ğŸ”§ TecnologÃ­as recomendadas:

- Apache Kafka (particiones por clave).
- Azure Service Bus (session-enabled queues).
- AWS Kinesis (shard key).
- RabbitMQ (routing keys).

---

## ğŸ­  Casos de aplicaciÃ³n reales :



| Industria   | Caso de uso                              | AplicaciÃ³n del patrÃ³n Convoy Secuencial |
|------------|-------------------------------------------|------------------------------------------|
| Bancaria   | Transacciones por cuenta                  | Mantiene el orden de depÃ³sitos y retiros |
| E-commerce | Pedidos por cliente                       | Asegura consistencia en stock y despacho |
| LogÃ­stica  | Seguimiento de paquetes                   | Procesa eventos en orden por tracking ID |
| SaaS       | Acciones por tenant (cliente empresarial) | AÃ­sla el procesamiento por cliente       |

---


## ğŸ“Œ 3.  Desarrollo del PatrÃ³n:


## ğŸ’» Proyecto de ejemplo: Procesamiento de Pedidos por Cliente

Este proyecto simula el procesamiento de pedidos en un sistema Kafka con mÃºltiples particiones. Cada pedido se asocia a un usuario, y se garantiza el orden por usuario.

### ğŸ—‚ï¸ Estructura del proyecto


sequential-convoy/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ producer.js
â””â”€â”€ consumer.js




---

### ğŸ³ docker-compose.yml

```yaml
version: '2'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:7.4.0
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1


ğŸ“¦ producer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "producer", brokers: ["localhost:9092"] });
const producer = kafka.producer();

const sendOrders = async () => {
  await producer.connect();

  const users = ["user1", "user2", "user3"];

  for (let i = 0; i < 10; i++) {
    const user = users[i % users.length];
    const order = {
      orderId: `order-${i}`,
      user,
      timestamp: new Date().toISOString(),
    };

    await producer.send({
      topic: "orders",
      messages: [
        {
          key: user,
          value: JSON.stringify(order),
        },
      ],
    });

    console.log(`ğŸ“¦ Enviado pedido: ${JSON.stringify(order)}`);
  }

  await producer.disconnect();
};

sendOrders();



âœ… consumer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "consumer", brokers: ["localhost:9092"] });

const consumer = kafka.consumer({ groupId: "order-group" });

const run = async () => {
  await consumer.connect();
  await consumer.subscribe({ topic: "orders", fromBeginning: true });

  await consumer.run({
    eachMessage: async ({ topic, partition, message }) => {
      const pedido = JSON.parse(message.value.toString());

      console.log(
        `âœ… Procesando pedido ${pedido.orderId} de ${pedido.user} en particiÃ³n ${partition}`
      );
    },
  });
};

run();

## PASOS ADICIONALES:

## ğŸ§ª Â¿CÃ³mo probarlo?

### ğŸš€ Levanta Kafka y Zookeeper:

```bash
docker-compose up -d

ğŸ“¦ Instala las dependencias:
npm init -y
npm install kafkajs
ğŸ§µ (Opcional) Crea el tÃ³pico si es necesario:
kafka-topics.sh --create --topic orders --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1
ğŸ› ï¸ Ejecuta el consumidor:
node consumer.js
ğŸ“¨ En otra terminal, ejecuta el productor:
node producer.js


ğŸ¯ Resultado Esperado
Los pedidos de cada usuario serÃ¡n procesados en orden (convoy secuencial), pero sin bloquear el procesamiento de otros usuarios gracias al uso de claves (por usuario) y particiones en Kafka.



## ğŸ“Œ 4.Entrega:



## ğŸ§ª Repositorio

ğŸ”— Repositorio del cÃ³digo:  
ğŸ‘‰ [Proyecto Convoy Secuencial en GitHub](https://github.com/HaroldUlima/ProyectoFinal/blob/main/Proyecto_convoy_secuencial)

---

## ğŸ¥ Video de DemostraciÃ³n

ğŸ“½ï¸ Link al video en YouTube:  
ğŸ‘‰ [Demo PatrÃ³n Convoy Secuencial - YouTube](https://www.youtube.com/watch?v=sTbShpPbV3E)

---

## ğŸ“š Fuentes y Lectura Recomendada

- ğŸ”— [KafkaJS - DocumentaciÃ³n Oficial](https://kafka.js.org/)
- ğŸ”— [Azure: PatrÃ³n Convoy Secuencial](https://learn.microsoft.com/en-us/azure/architecture/patterns/sequential-convoy)

---

## ğŸ“‹ Detalles TÃ©cnicos

1. Se crea un tÃ³pico Kafka llamado `orders` con **3 particiones**.
2. Cada mensaje contiene una **clave de usuario** para asegurar que todos sus mensajes vayan a la misma particiÃ³n.
3. El consumidor utiliza **KafkaJS** para escuchar y procesar los mensajes en orden.
4. Se simulan mÃºltiples usuarios enviando Ã³rdenes, y se observa cÃ³mo Kafka mantiene el orden por grupo sin afectar otros grupos.

---

## ğŸ§  ConclusiÃ³n

El patrÃ³n convoy secuencial permite mantener la lÃ³gica de orden sin comprometer la concurrencia del sistema. Este tipo de diseÃ±o es clave para arquitecturas de microservicios donde el procesamiento ordenado por contexto (usuario, sesiÃ³n, transacciÃ³n) es fundamental.









## Integrante 3
## Integrante 4
## Integrante 5
## Integrante 6