# 0.9. Trabajo Individual - Patrones Cloud (Informes y Videos)

## Manuel Malpartida - Retry

# El Patr√≥n Retry En Sistemas de E-Commerce

## Introducci√≥n
El patr√≥n Retry es un mecanismo de tolerancia a fallos dise√±ado para manejar errores transitorios en sistemas distribuidos. En el contexto de e-commerce, donde la disponibilidad y experiencia del usuario son cr√≠ticas, este patr√≥n permite recuperarse autom√°ticamente de fallas temporales en servicios externos como pasarelas de pago, APIs de inventario o sistemas de recomendaci√≥n.

## ¬øQu√© es el Patr√≥n Retry?
El patr√≥n Retry act√∫a como un sistema de recuperaci√≥n autom√°tica que:

- Detecta fallas temporales (timeouts, errores HTTP 5xx)
- Reintenta la operaci√≥n fallida siguiendo una pol√≠tica configurable
- Implementa tiempos de espera entre reintentos (backoff)
- Finaliza cuando tiene √©xito o alcanza el l√≠mite de intentos

**Ejemplo en e-commerce**:

- Cliente ‚Üí [Intento de pago ‚Üí Falla temporal ‚Üí Espera 1s ‚Üí Reintento ‚Üí √âxito]

## Problema que Resuelve en E-Commerce
**Desaf√≠os comunes**:
- Pagos fallidos: 15-20% de transacciones fallan inicialmente por inestabilidad en APIs de pago
- Disponibilidad de inventario: Contenciones en bases de datos durante ofertas flash
- Recomendaciones: Latencia variable en servicios de ML
- Notificaciones: Fallos en env√≠o de emails/notificaciones push

**Consecuencias sin Retry**:
- P√©rdida de ventas por fallas evitables
- Mala experiencia de usuario (errores visibles)
- Inconsistencias en datos cr√≠ticos

## Arquitectura del Patr√≥n
**Componentes clave**:
1. **Detector de fallas transitorias**: Clasifica errores como recuperables
2. **Pol√≠tica de reintentos**: Define m√°ximo de intentos y tiempos de espera
3. **Estrategia de backoff**: Calcula intervalos entre reintentos (ej: exponencial)
4. **Mecanismo de fallback**: Acci√≥n alternativa cuando se agotan los reintentos

**Flujo t√≠pico**:
1. Operaci√≥n falla por error transitorio
2. Sistema espera un intervalo calculado
3. Reintenta la operaci√≥n
4. Repite hasta √©xito o l√≠mite de intentos

## Implementaci√≥n en E-Commerce
**Tecnolog√≠as recomendadas**:
- Node.js: `async-retry`, `promise-retry`
- Java: Spring Retry, Resilience4j
- .NET: Polly
- Python: Tenacity

### Ejemplo pr√°ctico (Servicio de Pagos)
```javascript
const retry = require('async-retry');

// Simulador de servicio de pagos con fallas controladas
let attemptCount = 0;
const mockPaymentGateway = {
  charge: async (paymentData) => {
    attemptCount++;
    console.log(`üîµ Intento #${attemptCount} - Procesando pago $${paymentData.amount}`);
    
    // Simulamos fallas temporales en los primeros 2 intentos
    if (attemptCount < 3) {
      throw new Error('Error temporal: Servicio de pagos no disponible');
    }
    
    return { success: true, transactionId: `txn_${Date.now()}` };
  }
};

// Implementaci√≥n con patr√≥n Retry
async function processPayment(paymentData) {
  try {
    return await retry(
      async (bail) => {
        try {
          return await mockPaymentGateway.charge(paymentData);
        } catch (error) {
          if (error.message.includes('temporal')) {
            console.log(`üü° ${error.message} - Reintentando...`);
            throw error;
          }
          bail(error);
          return;
        }
      },
      {
        retries: 3,
        minTimeout: 1000,
        factor: 2,
        onRetry: (error) => {
          console.log(`‚è≥ Esperando ${error.attemptNumber * 1}s...`);
        }
      }
    );
  } catch (error) {
    console.error(`üî¥ Error final: ${error.message}`);
    return { success: false };
  }
}

// Ejecuci√≥n de prueba
(async () => {
  console.log('=== DEMO PATR√ìN RETRY EN E-COMMERCE ===');
  const result = await processPayment({ amount: 99.99 });
  console.log('Resultado final:', result);
})();
 
```

## Casos de Uso en E-Commerce

### Procesamiento de pagos:
- Reintentos cuando fallan conexiones con Stripe/PayPal.
- Backoff exponencial para evitar saturar el servicio.

### Reserva de inventario:
- Reintentos ante errores de concurrencia.
- Jitter para distribuir la carga.

### Sistema de recomendaciones:
- Reintentos con degradaci√≥n elegante (muestra resultados en cach√© primero).

### Notificaciones:
- Reintentos para enviar emails/notificaciones push.
- Encolamiento como fallback.

## Ventajas y Consideraciones

### Beneficios:
‚úì Mayor tasa de √©xito en transacciones.  
‚úì Mejor experiencia de usuario (menos errores visibles).  
‚úì Resiliencia autom√°tica ante fallas temporales.  

### Riesgos:
‚úó Puede enmascarar problemas subyacentes si no se monitorea.  
‚úó Posible saturaci√≥n si no se configura adecuadamente.  
‚úó No aplicable a operaciones no idempotentes.  

## Mejores Pr√°cticas
- Configurar l√≠mites razonables (3-5 reintentos).
- Usar backoff exponencial + jitter para evitar sincronizaci√≥n.
- Implementar circuit breakers para fallas prolongadas.
- Monitorear m√©tricas de reintentos (indicador de problemas).
- Evitar en operaciones no idempotentes (ej: POST que crean recursos).

## Conclusi√≥n
En sistemas de e-commerce, el patr√≥n Retry es esencial para manejar la inevitable inestabilidad de servicios distribuidos. Cuando se implementa correctamente, puede reducir fallas visibles al usuario en m√°s del 50%, mejorando significativamente la experiencia de compra y las m√©tricas de conversi√≥n.

# Video:

link: https://youtu.be/NrjG9d0cYWw 

## Integrante 2




## üìå 1.  Elecci√≥n de Tema:

# üß† Implementaci√≥n del Patr√≥n Cloud ‚Äì Convoy Secuencial

## üìå 2.  Desarrollo del Patr√≥n:


## Problema que resuelve el patr√≥n Convoy Secuencial

En sistemas distribuidos, especialmente aquellos que procesan mensajes en paralelo, surge un problema cuando:

- Se deben procesar mensajes **en orden por grupo** (ej. por cliente o por cuenta).
- El procesamiento de un grupo **bloquea a otros** si se hace secuencialmente.

### ‚ùó Ejemplos de problemas:

- Inconsistencias por procesar transacciones fuera de orden.
- Cuellos de botella si un proceso lento detiene todo el flujo.
- Ineficiencia al aplicar bloqueo global en lugar de por grupo.

---

## ‚úÖ Soluci√≥n que propone el patr√≥n

El patr√≥n **Sequential Convoy** permite procesar mensajes relacionados **en orden dentro de su grupo**, pero **sin bloquear otros grupos**. Se basa en:

- Agrupaci√≥n por claves (por ejemplo, `user_id`, `tenant_id`, `account_id`).
- Particionado de colas o t√≥picos por clave.
- Procesamiento concurrente entre grupos, pero ordenado dentro de cada uno.

### üîß Tecnolog√≠as recomendadas:

- Apache Kafka (particiones por clave).
- Azure Service Bus (session-enabled queues).
- AWS Kinesis (shard key).
- RabbitMQ (routing keys).

---

## üè≠  Casos de aplicaci√≥n reales :



| Industria   | Caso de uso                              | Aplicaci√≥n del patr√≥n Convoy Secuencial |
|------------|-------------------------------------------|------------------------------------------|
| Bancaria   | Transacciones por cuenta                  | Mantiene el orden de dep√≥sitos y retiros |
| E-commerce | Pedidos por cliente                       | Asegura consistencia en stock y despacho |
| Log√≠stica  | Seguimiento de paquetes                   | Procesa eventos en orden por tracking ID |
| SaaS       | Acciones por tenant (cliente empresarial) | A√≠sla el procesamiento por cliente       |

---


## üìå 3.  Desarrollo del Patr√≥n:


## üíª Proyecto de ejemplo: Procesamiento de Pedidos por Cliente

Este proyecto simula el procesamiento de pedidos en un sistema Kafka con m√∫ltiples particiones. Cada pedido se asocia a un usuario, y se garantiza el orden por usuario.

### üóÇÔ∏è Estructura del proyecto


sequential-convoy/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ producer.js
‚îî‚îÄ‚îÄ consumer.js




---

### üê≥ docker-compose.yml

```yaml
version: '2'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.4.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:7.4.0
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1


üì¶ producer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "producer", brokers: ["localhost:9092"] });
const producer = kafka.producer();

const sendOrders = async () => {
  await producer.connect();

  const users = ["user1", "user2", "user3"];

  for (let i = 0; i < 10; i++) {
    const user = users[i % users.length];
    const order = {
      orderId: `order-${i}`,
      user,
      timestamp: new Date().toISOString(),
    };

    await producer.send({
      topic: "orders",
      messages: [
        {
          key: user,
          value: JSON.stringify(order),
        },
      ],
    });

    console.log(`üì¶ Enviado pedido: ${JSON.stringify(order)}`);
  }

  await producer.disconnect();
};

sendOrders();



‚úÖ consumer.js

const { Kafka } = require("kafkajs");

const kafka = new Kafka({ clientId: "consumer", brokers: ["localhost:9092"] });

const consumer = kafka.consumer({ groupId: "order-group" });

const run = async () => {
  await consumer.connect();
  await consumer.subscribe({ topic: "orders", fromBeginning: true });

  await consumer.run({
    eachMessage: async ({ topic, partition, message }) => {
      const pedido = JSON.parse(message.value.toString());

      console.log(
        `‚úÖ Procesando pedido ${pedido.orderId} de ${pedido.user} en partici√≥n ${partition}`
      );
    },
  });
};

run();

## PASOS ADICIONALES:

## üß™ ¬øC√≥mo probarlo?

### üöÄ Levanta Kafka y Zookeeper:

```bash
docker-compose up -d

üì¶ Instala las dependencias:
npm init -y
npm install kafkajs
üßµ (Opcional) Crea el t√≥pico si es necesario:
kafka-topics.sh --create --topic orders --bootstrap-server localhost:9092 --partitions 3 --replication-factor 1
üõ†Ô∏è Ejecuta el consumidor:
node consumer.js
üì® En otra terminal, ejecuta el productor:
node producer.js


üéØ Resultado Esperado
Los pedidos de cada usuario ser√°n procesados en orden (convoy secuencial), pero sin bloquear el procesamiento de otros usuarios gracias al uso de claves (por usuario) y particiones en Kafka.



## üìå 4.Entrega:



## üß™ Repositorio

üîó Repositorio del c√≥digo:  
üëâ [Proyecto Convoy Secuencial en GitHub](https://github.com/HaroldUlima/ProyectoFinal/blob/main/Proyecto_convoy_secuencial)

---

## üé• Video de Demostraci√≥n

üìΩÔ∏è Link al video en YouTube:  
üëâ [Demo Patr√≥n Convoy Secuencial - YouTube](https://www.youtube.com/watch?v=sTbShpPbV3E)

---

## üìö Fuentes y Lectura Recomendada

- üîó [KafkaJS - Documentaci√≥n Oficial](https://kafka.js.org/)
- üîó [Azure: Patr√≥n Convoy Secuencial](https://learn.microsoft.com/en-us/azure/architecture/patterns/sequential-convoy)

---

## üìã Detalles T√©cnicos

1. Se crea un t√≥pico Kafka llamado `orders` con **3 particiones**.
2. Cada mensaje contiene una **clave de usuario** para asegurar que todos sus mensajes vayan a la misma partici√≥n.
3. El consumidor utiliza **KafkaJS** para escuchar y procesar los mensajes en orden.
4. Se simulan m√∫ltiples usuarios enviando √≥rdenes, y se observa c√≥mo Kafka mantiene el orden por grupo sin afectar otros grupos.

---

## üß† Conclusi√≥n

El patr√≥n convoy secuencial permite mantener la l√≥gica de orden sin comprometer la concurrencia del sistema. Este tipo de dise√±o es clave para arquitecturas de microservicios donde el procesamiento ordenado por contexto (usuario, sesi√≥n, transacci√≥n) es fundamental.


## Integrante 3
Diego Saravia

Ejecuci√≥n del Proceso: Implementar Cache-aside con Redis y Node.js

Paso 1: Requisitos previos
1. Instalar Node.js
2. Instalar Redis
sudo apt update
sudo apt install redis-server

Paso 2: Crear el proyecto

Paso 3: Crear el archivo del servidor
Crea el archivo server.js:
touch server.js

const express = require('express');
const redis = require('redis');

const app = express();
const port = 3000;

// Crear cliente de Redis
const client = redis.createClient();

client.connect().catch(console.error);

// Simular base de datos
const fakeDB = {
  1: { id: 1, name: "Laptop", price: 1200 },
  2: { id: 2, name: "Mouse", price: 25 },
  3: { id: 3, name: "Keyboard", price: 45 }
};

// Endpoint con estrategia cache-aside
app.get('/product/:id', async (req, res) => {
  const id = req.params.id;

  try {
    // 1. Buscar en cach√©
    const cached = await client.get(`product:${id}`);
    if (cached) {
      return res.json({ source: "cache", data: JSON.parse(cached) });
    }

    // 2. Buscar en "base de datos"
    const product = fakeDB[id];
    if (!product) return res.status(404).json({ error: "Producto no encontrado" });

    // 3. Guardar en cach√© por 60 segundos
    await client.setEx(`product:${id}`, 60, JSON.stringify(product));

    // 4. Responder con datos de base de datos
    res.json({ source: "database", data: product });

  } catch (err) {
    console.error("Error:", err);
    res.status(500).json({ error: "Error interno" });
  }
});

app.listen(port, () => {
  console.log(`Servidor en http://localhost:${port}`);
});

Paso 4: Ejecutar el servidor
node server.js
Servidor en http://localhost:3000

Paso 5: Probar el endpoint
Abrir navegador o usa Postman/cURL:
Despu√©s de 60 segundos:
Redis elimina el valor (por TTL), y se vuelve a consultar la ‚Äúbase de datos‚Äù.


## Integrante 4
## Integrante 5
## Integrante 6