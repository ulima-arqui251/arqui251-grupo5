# 0.10. Temas Individuales por Integrante - Parte 2 (Informes)

# üõí ShopCart Federated - Arquitectura de Software  
**Autor:** Harold Mu√±ante Durand  

Este proyecto implementa una simulaci√≥n de **aprendizaje federado (Federated Learning)** aplicado a una tienda virtual llamada **ShopCart**. Utiliza `scikit-learn`, `numpy` y t√©cnicas b√°sicas de federated averaging para entrenar un modelo de clasificaci√≥n sin compartir datos sensibles entre clientes.

---

## üìå Objetivo del Proyecto

Demostrar el uso de una **arquitectura basada en aprendizaje federado** para proteger la privacidad de los datos de usuarios simulados, mientras se construyen modelos de machine learning colaborativos.

El objetivo se alinea con pr√°cticas modernas de arquitectura distribuida, promoviendo **escalabilidad**, **privacidad** y **descentralizaci√≥n** en soluciones e-commerce inteligentes.

---

## üß± Estructura del Proyecto

shopcart_federated_sklearn/
‚îÇ
‚îú‚îÄ‚îÄ client_data.py # Generaci√≥n de datos simulados por cliente
‚îú‚îÄ‚îÄ db_handler.py # Manejador de base de datos SQLite
‚îú‚îÄ‚îÄ federated_training.py # L√≥gica de entrenamiento federado
‚îú‚îÄ‚îÄ main.py # Script principal de ejecuci√≥n
‚îú‚îÄ‚îÄ federated_results.db # Base de datos con resultados
‚îî‚îÄ‚îÄ venv/ # Entorno virtual de Python


---

## üß† Descripci√≥n de Componentes

### `client_data.py`


``` python
from sklearn.datasets import make_classification
import numpy as np

def create_client_data(num_clients=5, samples_per_client=100):
    clients = []
    for _ in range(num_clients):
        X, y = make_classification(n_samples=samples_per_client, n_features=10,
                                   n_informative=5, n_classes=2, random_state=np.random.randint(10000))
        clients.append((X, y))
    return clients

### `db_handler.py'


import sqlite3

def initialize_db():
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS results (
            round INTEGER,
            accuracy REAL,
            loss REAL
        )
    ''')
    conn.commit()
    conn.close()

def save_result(round_num, accuracy, loss):
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('INSERT INTO results (round, accuracy, loss) VALUES (?, ?, ?)', (round_num, accuracy, loss))
    conn.commit()
    conn.close()


###  'federated_training.py'


import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, log_loss

def federated_average(models):
    avg_weights = np.mean([model.coef_ for model in models], axis=0)
    avg_intercept = np.mean([model.intercept_ for model in models], axis=0)
    return avg_weights, avg_intercept

def run_federated_training(clients, num_rounds=5):
    global_model = LogisticRegression(max_iter=1000)
    X_test, y_test = clients[0]

    for round_num in range(1, num_rounds + 1):
        local_models = []
        for X, y in clients:
            local_model = LogisticRegression(max_iter=1000)
            local_model.fit(X, y)
            local_models.append(local_model)

        avg_weights, avg_intercept = federated_average(local_models)
        global_model.coef_ = avg_weights
        global_model.intercept_ = avg_intercept

        logits = global_model.predict_proba(X_test)
        y_pred = global_model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        loss = log_loss(y_test, logits)

        yield round_num, acc, loss

### 'main.py'


from client_data import create_client_data
from db_handler import initialize_db, save_result
from federated_training import run_federated_training

initialize_db()
clients = create_client_data()

for round_num, acc, loss in run_federated_training(clients):
    print(f"Ronda {round_num} ‚Üí Acc: {acc:.3f}, Loss: {loss:.3f}")
    save_result(round_num, acc, loss)


‚ñ∂Ô∏è Instrucciones de Ejecuci√≥n
1. Clona el repositorio:

git clone https://github.com/tu_usuario/shopcart_federated_sklearn.git
cd shopcart_federated_sklearn

2. Crea y activa un entorno virtual (Windows):
python -m venv venv
.\venv\Scripts\activate
# Si da error, ejecuta en PowerShell: Set-ExecutionPolicy RemoteSigned -Scope CurrentUser

3. Instala las dependencias:

pip install --upgrade pip
pip install scikit-learn numpy

4. Ejecuta el script principal:

python main.py

Deber√≠as ver resultados como:

Ronda 1 ‚Üí Acc: 0.920, Loss: 0.439
Ronda 2 ‚Üí Acc: 0.860, Loss: 0.432

Los resultados tambi√©n se almacenan en federated_results.db.



üìä Visualizaci√≥n de M√©tricas
Este m√≥dulo permite visualizar c√≥mo evolucionan la precisi√≥n y la p√©rdida del modelo a lo largo de las rondas de entrenamiento federado. Utiliza una base de datos SQLite (federated_results.db) donde se almacenan las m√©tricas.

üîß Requisitos
Aseg√∫rate de tener instalados los siguientes paquetes:


pip install pandas matplotlib

üìÅ Estructura esperada de la base de datos
La base de datos federated_results.db debe contener una tabla llamada metrics con las siguientes columnas:

round (INT): n√∫mero de ronda

accuracy (FLOAT): precisi√≥n del modelo en esa ronda

loss (FLOAT): p√©rdida del modelo en esa ronda

‚ñ∂Ô∏è Ejecuci√≥n
Desde la terminal, ejecuta:


python visualize_metrics.py
Se mostrar√° una tabla con los resultados y dos gr√°ficas:

Precisi√≥n por ronda

P√©rdida por ronda

üìÑ C√≥digo: visualize_metrics.py


import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# 1. Conectar a la base de datos local (debe estar en el mismo directorio)
conn = sqlite3.connect("federated_results.db")
df = pd.read_sql_query("SELECT * FROM metrics ORDER BY round", conn)
conn.close()

# 2. Mostrar la tabla en consola
print("\nM√©tricas registradas:")
print(df.to_string(index=False))

# 3. Gr√°fica de precisi√≥n por ronda
plt.figure()
plt.plot(df['round'], df['accuracy'], marker='o')
plt.title('Precisi√≥n por Ronda')
plt.xlabel('Ronda')
plt.ylabel('Precisi√≥n')
plt.grid(True)
plt.tight_layout()
plt.show()

# 4. Gr√°fica de p√©rdida por ronda
plt.figure()
plt.plot(df['round'], df['loss'], marker='o')
plt.title('P√©rdida por Ronda')
plt.xlabel('Ronda')
plt.ylabel('P√©rdida')
plt.grid(True)
plt.tight_layout()
plt.show()




üìä Posibles Mejoras Futuras
A√±adir visualizaci√≥n autom√°tica con matplotlib o streamlit.

Guardar modelos serializados (joblib, pickle).

Simulaci√≥n con datos reales o anonimizaci√≥n avanzada.

Integraci√≥n con TensorFlow Federated o PySyft para mayor realismo.


üß† Conclusi√≥n
Este proyecto demuestra una arquitectura federada aplicada a un caso de negocio moderno (ShopCart), ofreciendo un enfoque escalable y centrado en la privacidad para el entrenamiento de modelos de inteligencia artificial.


‚öôÔ∏è Requisitos
Python 3.12 (recomendado)

scikit-learn

numpy