# ğŸ›’ ShopCart Federated - Arquitectura de Software  
**Autor:** Harold MuÃ±ante Durand  

Este proyecto implementa una simulaciÃ³n de **aprendizaje federado (Federated Learning)** aplicado a una tienda virtual llamada **ShopCart**. Utiliza `scikit-learn`, `numpy` y tÃ©cnicas bÃ¡sicas de federated averaging para entrenar un modelo de clasificaciÃ³n sin compartir datos sensibles entre clientes.

---

## ğŸ“Œ Objetivo del Proyecto

Demostrar el uso de una **arquitectura basada en aprendizaje federado** para proteger la privacidad de los datos de usuarios simulados, mientras se construyen modelos de machine learning colaborativos.

---


## ğŸ§  Â¿Por quÃ© Aprendizaje Federado en Shopcart?

El **aprendizaje federado** permite que mÃºltiples usuarios (clientes de Shopcart) entrenen conjuntamente un modelo de recomendaciÃ³n sin necesidad de enviar sus datos al servidor central. En lugar de eso, cada cliente entrena un modelo localmente y solo envÃ­a los **pesos del modelo** para ser promediados globalmente.

Esto beneficia a Shopcart en:

- âœ… ProtecciÃ³n de datos personales (cumple con GDPR y otras regulaciones)
- âœ… Recomendaciones personalizadas respetando la privacidad
- âœ… Mayor fidelizaciÃ³n por confianza del usuario
- âœ… Escalabilidad y arquitectura distribuida moderna

---

## ğŸ›ï¸ Arquitectura Propuesta

```text
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    Interfaz Emocional      â”‚
         â”‚  (Shopcart Frontend App)   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Nodo Cliente (dispositivo)   â”‚
       â”‚  - Entrena modelo local       â”‚
       â”‚  - Datos emocionales y UX     â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   Servidor de CoordinaciÃ³n    â”‚
       â”‚  - Agrega pesos (Federated)   â”‚
       â”‚  - Mide precisiÃ³n y pÃ©rdida   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    Almacenamiento DB   â”‚
         â”‚  SQLite / PostgreSQL   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

## ğŸ§± Estructura del Proyecto

shopcart_federated_sklearn/
â”‚
â”œâ”€â”€ client_data.py # GeneraciÃ³n de datos simulados por cliente
â”œâ”€â”€ db_handler.py # Manejador de base de datos SQLite
â”œâ”€â”€ federated_training.py # LÃ³gica de entrenamiento federado
â”œâ”€â”€ main.py # Script principal de ejecuciÃ³n
â”œâ”€â”€ visualize_metrics.py # VisualizaciÃ³n de mÃ©tricas de precisiÃ³n y pÃ©rdida
â”œâ”€â”€ federated_results.db # Base de datos con resultados
â””â”€â”€ venv/ # Entorno virtual de Python




---

## ğŸ§  Componentes del Proyecto

### `client_data.py`
```python
from sklearn.datasets import make_classification
import numpy as np

def create_client_data(num_clients=5, samples_per_client=100):
    clients = []
    for _ in range(num_clients):
        X, y = make_classification(n_samples=samples_per_client, n_features=10,
                                   n_informative=5, n_classes=2, random_state=np.random.randint(10000))
        clients.append((X, y))
    return clients


### `db_handler.py`


import sqlite3

def initialize_db():
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS metrics (
            round INTEGER,
            accuracy REAL,
            loss REAL
        )
    ''')
    conn.commit()
    conn.close()

def save_result(round_num, accuracy, loss):
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('INSERT INTO metrics (round, accuracy, loss) VALUES (?, ?, ?)', (round_num, accuracy, loss))
    conn.commit()
    conn.close()


### federated_training.py


import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, log_loss

def federated_average(models):
    avg_weights = np.mean([model.coef_ for model in models], axis=0)
    avg_intercept = np.mean([model.intercept_ for model in models], axis=0)
    return avg_weights, avg_intercept

def run_federated_training(clients, num_rounds=5):
    global_model = LogisticRegression(max_iter=1000)
    X_test, y_test = clients[0]

    for round_num in range(1, num_rounds + 1):
        local_models = []
        for X, y in clients:
            local_model = LogisticRegression(max_iter=1000)
            local_model.fit(X, y)
            local_models.append(local_model)

        avg_weights, avg_intercept = federated_average(local_models)
        global_model.coef_ = avg_weights
        global_model.intercept_ = avg_intercept

        logits = global_model.predict_proba(X_test)
        y_pred = global_model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        loss = log_loss(y_test, logits)

        yield round_num, acc, loss



### main.py


from client_data import create_client_data
from db_handler import initialize_db, save_result
from federated_training import run_federated_training

initialize_db()
clients = create_client_data()

for round_num, acc, loss in run_federated_training(clients):
    print(f"Ronda {round_num} â†’ Acc: {acc:.3f}, Loss: {loss:.3f}")
    save_result(round_num, acc, loss)



â–¶ï¸ Instrucciones de EjecuciÃ³n
1. Clona el repositorio:
git clone https://github.com/tu_usuario/shopcart_federated_sklearn.git
cd shopcart_federated_sklearn

2. Crea y activa un entorno virtual (Windows):
python -m venv venv
.\venv\Scripts\activate

Si da error, ejecuta en PowerShell:
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser


3. Instala las dependencias:

pip install --upgrade pip
pip install scikit-learn numpy

4. Ejecuta el script principal:

python main.py


ğŸ“Š VisualizaciÃ³n de MÃ©tricas

pip install pandas matplotlib

### visualize_metrics.py

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

conn = sqlite3.connect("federated_results.db")
df = pd.read_sql_query("SELECT * FROM metrics ORDER BY round", conn)
conn.close()

print("\nMÃ©tricas registradas:")
print(df.to_string(index=False))

plt.figure()
plt.plot(df['round'], df['accuracy'], marker='o')
plt.title('PrecisiÃ³n por Ronda')
plt.xlabel('Ronda')
plt.ylabel('PrecisiÃ³n')
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure()
plt.plot(df['round'], df['loss'], marker='o')
plt.title('PÃ©rdida por Ronda')
plt.xlabel('Ronda')
plt.ylabel('PÃ©rdida')
plt.grid(True)
plt.tight_layout()
plt.show()


ğŸ“ˆ Ejemplo de Salida

Ronda 1 â†’ Acc: 0.920, Loss: 0.439
Ronda 2 â†’ Acc: 0.860, Loss: 0.432
Ronda 3 â†’ Acc: 0.900, Loss: 0.442
...

La precisiÃ³n y la pÃ©rdida se visualizan tambiÃ©n mediante grÃ¡ficas de evoluciÃ³n por ronda.

ğŸŒ± Mejoras Futuras
Uso de datos reales o anonimizaciÃ³n de datos de usuarios.

IntegraciÃ³n con TensorFlow Federated.

Almacenamiento de modelos con joblib o pickle.

Dashboard visual con streamlit.

ğŸ§  ConclusiÃ³n
Este proyecto demuestra una arquitectura federada aplicada a un caso de negocio moderno (ShopCart), ofreciendo un enfoque escalable y centrado en la privacidad para el entrenamiento de modelos de inteligencia artificial.

âš™ï¸ Requisitos TÃ©cnicos
Python 3.12

scikit-learn

numpy

pandas

matplotlib


ğŸ”— Referencias
Scikit-learn Documentation

SQLite Python Docs

Federated Learning - Google AI Blog

--------------------------------------------------------------
- Linkea Serverless - Arquitectura de Software
Autor:  Carolina Alexandra Ramirez De La Cuba

Este proyecto implementa una arquitectura serverless utilizando AWS Lambda y API Gateway para simular funciones clave de la plataforma Linkea, una aplicaciÃ³n acadÃ©mica colaborativa entre estudiantes. El backend no depende de servidores persistentes y se basa completamente en ejecuciÃ³n bajo demanda.

- Objetivo del Proyecto
Demostrar cÃ³mo una arquitectura sin servidor puede ofrecer una soluciÃ³n escalable, econÃ³mica y de bajo mantenimiento para aplicaciones web modernas como Linkea, enfocada en la conexiÃ³n acadÃ©mica entre estudiantes.

- Â¿Por quÃ© Serverless en Linkea?
Linkea busca reducir costos y escalar fÃ¡cilmente segÃºn el uso real. La arquitectura serverless permite:

Ejecutar funciones como servicios independientes (FaaS)
Reducir costos (se paga solo por ejecuciÃ³n)
Eliminar mantenimiento de servidores
Escalar automÃ¡ticamente sin configuraciÃ³n extra
Desarrollar y desplegar funciones rÃ¡pidamente

ğŸ›ï¸ Arquitectura Propuesta
java
Copiar
Editar
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Interfaz Web/MÃ³vil      â”‚
        â”‚    (Next.js / Flutter)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   API Gateway        â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚      AWS Lambda (FaaS)     â”‚
         â”‚  - Crear usuario           â”‚
         â”‚  - Subir apuntes           â”‚
         â”‚  - Buscar grupos de estudioâ”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚     DynamoDB         â”‚
           â”‚  (Base de datos NoSQL)â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
- Estructura del Proyecto
linkea_serverless_demo/

bash
Copiar
Editar
â”œâ”€â”€ create_user.py           # FunciÃ³n Lambda para registrar un nuevo usuario
â”œâ”€â”€ upload_notes.py          # FunciÃ³n Lambda para subir apuntes
â”œâ”€â”€ find_groups.py           # FunciÃ³n Lambda para buscar coincidencias de estudio
â”œâ”€â”€ template.yaml            # DefiniciÃ³n de infraestructura (AWS SAM)
â”œâ”€â”€ README.md                # Instrucciones del proyecto
â””â”€â”€ tests/                   # Pruebas unitarias de cada funciÃ³n
- Componentes del Proyecto
create_user.py
python
Copiar
Editar
import json

def lambda_handler(event, context):
    body = json.loads(event['body'])
    email = body.get('email')
    name = body.get('name')

    if not email or not name:
        return {"statusCode": 400, "body": "Datos faltantes"}

    return {
        "statusCode": 200,
        "body": f"Usuario {name} registrado con email {email}"
    }
upload_notes.py
python
Copiar
Editar
def lambda_handler(event, context):
    body = json.loads(event['body'])
    note_title = body.get('title')

    return {
        "statusCode": 200,
        "body": f"Apunte '{note_title}' subido exitosamente"
    }
â–¶ Instrucciones de EjecuciÃ³n
Requisitos
AWS CLI configurado (aws configure)

Node.js y AWS SAM CLI instalados

Cuenta de AWS con permisos para Lambda, API Gateway, DynamoDB

Pasos
Clona el repositorio:

bash
Copiar
Editar
git clone https://github.com/carolinardlc/linkea_serverless
cd linkea_serverless_demo
Empaqueta el proyecto con SAM:

bash
Copiar
Editar
sam build
Despliega en AWS:

bash
Copiar
Editar
sam deploy --guided
Prueba las funciones usando Postman o curl:

bash
Copiar
Editar
curl -X POST https://mi-api-url.amazonaws.com/dev/create-user \
     -d '{"email":"ejemplo@ulima.edu.pe", "name":"Carolina"}'
- Resultados Esperados
Funciones Lambda que se ejecutan al instante segÃºn el evento.

Registro exitoso de usuarios y simulaciÃ³n de funcionalidades sin backend tradicional.

Uso mÃ­nimo de recursos y costos gracias al modelo pay-per-use.

- Mejoras Futuras
Conectar con DynamoDB para almacenamiento real.

ValidaciÃ³n con correo institucional.

IncorporaciÃ³n de Cognito para login sin servidor.

Frontend Next.js como cliente de las APIs serverless.

- ConclusiÃ³n
Este proyecto demuestra cÃ³mo la arquitectura serverless es ideal para proyectos educativos y colaborativos como Linkea. Reduce costos, mejora la escalabilidad y acelera el desarrollo sin preocuparse por la infraestructura.

- Requisitos TÃ©cnicos
AWS SAM CLI

Python 3.11

AWS CLI configurado

Cuenta de AWS

- Referencias
AWS Lambda

Serverless Framework

Amazon API Gateway

Arquitectura Serverless - Martin Fowler

