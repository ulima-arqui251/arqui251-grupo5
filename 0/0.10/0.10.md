# 🛒 ShopCart Federated - Arquitectura de Software  
**Autor:** Harold Muñante Durand  

Este proyecto implementa una simulación de **aprendizaje federado (Federated Learning)** aplicado a una tienda virtual llamada **ShopCart**. Utiliza `scikit-learn`, `numpy` y técnicas básicas de federated averaging para entrenar un modelo de clasificación sin compartir datos sensibles entre clientes.

---

## 📌 Objetivo del Proyecto

Demostrar el uso de una **arquitectura basada en aprendizaje federado** para proteger la privacidad de los datos de usuarios simulados, mientras se construyen modelos de machine learning colaborativos.

---


## 🧠 ¿Por qué Aprendizaje Federado en Shopcart?

El **aprendizaje federado** permite que múltiples usuarios (clientes de Shopcart) entrenen conjuntamente un modelo de recomendación sin necesidad de enviar sus datos al servidor central. En lugar de eso, cada cliente entrena un modelo localmente y solo envía los **pesos del modelo** para ser promediados globalmente.

Esto beneficia a Shopcart en:

- ✅ Protección de datos personales (cumple con GDPR y otras regulaciones)
- ✅ Recomendaciones personalizadas respetando la privacidad
- ✅ Mayor fidelización por confianza del usuario
- ✅ Escalabilidad y arquitectura distribuida moderna

---

## 🏛️ Arquitectura Propuesta

```text
         ┌────────────────────────────┐
         │    Interfaz Emocional      │
         │  (Shopcart Frontend App)   │
         └────────────┬───────────────┘
                      │
                      ▼
       ┌───────────────────────────────┐
       │  Nodo Cliente (dispositivo)   │
       │  - Entrena modelo local       │
       │  - Datos emocionales y UX     │
       └────────────┬──────────────────┘
                    ▼
       ┌───────────────────────────────┐
       │   Servidor de Coordinación    │
       │  - Agrega pesos (Federated)   │
       │  - Mide precisión y pérdida   │
       └────────────┬──────────────────┘
                    ▼
         ┌────────────────────────┐
         │    Almacenamiento DB   │
         │  SQLite / PostgreSQL   │
         └────────────────────────┘

## 🧱 Estructura del Proyecto

shopcart_federated_sklearn/
│
├── client_data.py # Generación de datos simulados por cliente
├── db_handler.py # Manejador de base de datos SQLite
├── federated_training.py # Lógica de entrenamiento federado
├── main.py # Script principal de ejecución
├── visualize_metrics.py # Visualización de métricas de precisión y pérdida
├── federated_results.db # Base de datos con resultados
└── venv/ # Entorno virtual de Python




---

## 🧠 Componentes del Proyecto
```
### `client_data.py`
```python
from sklearn.datasets import make_classification
import numpy as np

def create_client_data(num_clients=5, samples_per_client=100):
    clients = []
    for _ in range(num_clients):
        X, y = make_classification(n_samples=samples_per_client, n_features=10,
                                   n_informative=5, n_classes=2, random_state=np.random.randint(10000))
        clients.append((X, y))
    return clients


### `db_handler.py`


import sqlite3

def initialize_db():
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS metrics (
            round INTEGER,
            accuracy REAL,
            loss REAL
        )
    ''')
    conn.commit()
    conn.close()

def save_result(round_num, accuracy, loss):
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('INSERT INTO metrics (round, accuracy, loss) VALUES (?, ?, ?)', (round_num, accuracy, loss))
    conn.commit()
    conn.close()


### federated_training.py


import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, log_loss

def federated_average(models):
    avg_weights = np.mean([model.coef_ for model in models], axis=0)
    avg_intercept = np.mean([model.intercept_ for model in models], axis=0)
    return avg_weights, avg_intercept

def run_federated_training(clients, num_rounds=5):
    global_model = LogisticRegression(max_iter=1000)
    X_test, y_test = clients[0]

    for round_num in range(1, num_rounds + 1):
        local_models = []
        for X, y in clients:
            local_model = LogisticRegression(max_iter=1000)
            local_model.fit(X, y)
            local_models.append(local_model)

        avg_weights, avg_intercept = federated_average(local_models)
        global_model.coef_ = avg_weights
        global_model.intercept_ = avg_intercept

        logits = global_model.predict_proba(X_test)
        y_pred = global_model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        loss = log_loss(y_test, logits)

        yield round_num, acc, loss



### main.py


from client_data import create_client_data
from db_handler import initialize_db, save_result
from federated_training import run_federated_training

initialize_db()
clients = create_client_data()

for round_num, acc, loss in run_federated_training(clients):
    print(f"Ronda {round_num} → Acc: {acc:.3f}, Loss: {loss:.3f}")
    save_result(round_num, acc, loss)

```

▶️ Instrucciones de Ejecución
1. Clona el repositorio:
git clone https://github.com/tu_usuario/shopcart_federated_sklearn.git
cd shopcart_federated_sklearn

2. Crea y activa un entorno virtual (Windows):
python -m venv venv
.\venv\Scripts\activate

Si da error, ejecuta en PowerShell:
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser


3. Instala las dependencias:

pip install --upgrade pip
pip install scikit-learn numpy

4. Ejecuta el script principal:

---

```python main.py


📊 Visualización de Métricas

pip install pandas matplotlib

### visualize_metrics.py

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

conn = sqlite3.connect("federated_results.db")
df = pd.read_sql_query("SELECT * FROM metrics ORDER BY round", conn)
conn.close()

print("\nMétricas registradas:")
print(df.to_string(index=False))

plt.figure()
plt.plot(df['round'], df['accuracy'], marker='o')
plt.title('Precisión por Ronda')
plt.xlabel('Ronda')
plt.ylabel('Precisión')
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure()
plt.plot(df['round'], df['loss'], marker='o')
plt.title('Pérdida por Ronda')
plt.xlabel('Ronda')
plt.ylabel('Pérdida')
plt.grid(True)
plt.tight_layout()
plt.show()

```

📈 Ejemplo de Salida

Ronda 1 → Acc: 0.920, Loss: 0.439
Ronda 2 → Acc: 0.860, Loss: 0.432
Ronda 3 → Acc: 0.900, Loss: 0.442
...

La precisión y la pérdida se visualizan también mediante gráficas de evolución por ronda.

🌱 Mejoras Futuras
Uso de datos reales o anonimización de datos de usuarios.

Integración con TensorFlow Federated.

Almacenamiento de modelos con joblib o pickle.

Dashboard visual con streamlit.

🧠 Conclusión
Este proyecto demuestra una arquitectura federada aplicada a un caso de negocio moderno (ShopCart), ofreciendo un enfoque escalable y centrado en la privacidad para el entrenamiento de modelos de inteligencia artificial.

⚙️ Requisitos Técnicos
Python 3.12

scikit-learn

numpy

pandas

matplotlib


🔗 Referencias
Scikit-learn Documentation

SQLite Python Docs


## 
Federated Learning - Google AI Blog

## **Andy Arribasplata Muñoz - Comunicación en tiempo real - websockets (Sistema de chat)**

---

### 1. Desarrollo Conceptual

Websocket es un protocolo o una serie de pasos para iniciar una conversacion en tiempo real entre cliente y servidor de forma que la comunicacion es continua y bidireccional. Inicialmente cuando se abre una pagina web de chat se realiza una conexion http con el servidor, luego se realiza un acuerdo donde el cliente le solicita
al servidor cambiar el protocolo de http a websocket y el servidor acepta, y comienza la comunicacion en tiempo real.

### 2. Consideraciones Técnicas

#### Pasos Técnicos

##### Creación de Proyecto de Chat e instalacion de paquetes

En Visual Studio Code dentro de una carpeta:
1. npm init -y: Crear proyecto con archivo package.json
2. npm i express: Instalar express
3. npm i nodemon: Nodemon actualiza servidor cada vez que se modifica codigo
4. npm i socket.io: Socket.io permite usar el procolo socket para la 
comunicacion en tiempo real en el chat

##### Configuración del servidor

1. Crear un archivo index.js
2. En package.json en scripts agregar "start": "nodemon index.js" para ejecutar el servidor
usando npm start y se actualize automaticamente al modificar codigo
3. En index.js crear aplicacion express, crear servidor http y hacer que servidor escuche en el puerto 3000

##### Configuración del cliente

1. Crear carpeta cliente, dentro crear archivo index.html y colocar codigo html de la seccion demo
para tener el frontend del chat
2. Colocar res.sendFile(__dirname + '/cliente/index.html') dentro de app.get con ruta '/' para mostrar
el chat del index.js al entrar a la pagina con link: http://localhost:3000/

##### Usar socket.io para enviar mensajes en el chat

1. Crear servidor socket, pasarle el servidor http y probar que un usuario se ha conectado
2. Usar biblioteca de socket en el cliente mediante un script
3. En el cliente al enviar un mensaje usar socket.emit, en el servidor recibirlo con socket.on,
para que el servidor se lo envie a todos los clientes usar io.emit y en el cliente recibirlo con
socket.on para luego mostrarlo
4. Duplicar la pestaña del navegador para tener otro cliente en el mismo link, enviar mensaje en algun cliente y 
verificar si ha sido recibido en el otro

---

#### 4. Demo: Uso de Socket para crear chat

Ahora se mostrara el codigo de el servidor y del cliente para una implementacion sencilla
de socket para crear un chat

##### Index.js: Servidor

```javascript
const express = require('express');
const app = express();
const http = require('http');
const server = http.createServer(app);
const { Server } = require("socket.io");
const io = new Server(server);

io.on('connection',(socket)=>{
    //console.log("usuario conectado")
    console.log(socket.id)
    socket.on('mensaje',(msg)=>{
       io.emit('mensaje',msg)
    })
})



app.get('/', (req, res) => {
  //res.send('<h1>Hello world</h1>');
  //console.log(__dirname)
  res.sendFile(__dirname + '/cliente/index.html')
});

server.listen(3000, () => {
  console.log('listening on *:3000');
});
```

##### Index.html: Cliente

```html
<!DOCTYPE html>
<html>

<head>
    <title>Socket.IO chat</title>
    <style>
        body {
            margin: 0;
            padding-bottom: 3rem;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #form {
            background: rgba(0, 0, 0, 0.15);
            padding: 0.25rem;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            height: 3rem;
            box-sizing: border-box;
            backdrop-filter: blur(10px);
        }

        #input {
            border: none;
            padding: 0 1rem;
            flex-grow: 1;
            border-radius: 2rem;
            margin: 0.25rem;
        }

        #input:focus {
            outline: none;
        }

        #form>button {
            background: #333;
            border: none;
            padding: 0 1rem;
            margin: 0.25rem;
            border-radius: 3px;
            outline: none;
            color: #fff;
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        #messages>li {
            padding: 0.5rem 1rem;
        }

        #messages>li:nth-child(odd) {
            background: #efefef;
        }
    </style>
</head>

<body>
    <ul id="messages"></ul>
    <form id="form" action="">
        <input id="input" autocomplete="off" /><button>Send</button>
    </form>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        var socket = io();
        //referenciar elementos
        var form = document.getElementById('form');
        var input = document.getElementById('input');
        var mensajes = document.getElementById('messages');

        form.addEventListener('submit',(e)=>{
            e.preventDefault();
            if(input.value){
                socket.emit('mensaje',input.value);
                input.value='';
            }
        })

        socket.on('mensaje',(msg)=>{
            var item = document.createElement('li');
            item.textContent = msg
            mensajes.appendChild(item);
            window.scrollTo(0, document.body.scrollHeight);
        })
    </script>
</body>

</html>
```

##### package.json

```json
{
  "name": "prueba-websocket",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "nodemon index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^5.1.0",
    "nodemon": "^3.1.10",
    "socket.io": "^4.8.1"
  }
}
```
Duplicar pestaña del navegador, enviar mensaje en alguna y 
verificar si ha sido recibido en la otra

---

#### 6. Conclusión

El uso del protocolo Socket facilita la comunicacion en tiempo real y sin interrupciones, lo cual se
puedo utilizar de forma practica y sencilla para la creacion de un chat. Además, Socket.io permite usar metodos 
para el envio y recepcion de mensajes de forma intuitiva entre cliente y servidor.

---

#### 7. Referencias

- [Documentación de Websocket.org](https://websocket.org/guides/websocket-protocol/)
- [Documentación de Socket.io](https://socket.io/get-started/chat)

---