# 🛒 ShopCart Federated - Arquitectura de Software  
**Autor:** Harold Muñante Durand  

Este proyecto implementa una simulación de **aprendizaje federado (Federated Learning)** aplicado a una tienda virtual llamada **ShopCart**. Utiliza `scikit-learn`, `numpy` y técnicas básicas de federated averaging para entrenar un modelo de clasificación sin compartir datos sensibles entre clientes.

---

## 📌 Objetivo del Proyecto

Demostrar el uso de una **arquitectura basada en aprendizaje federado** para proteger la privacidad de los datos de usuarios simulados, mientras se construyen modelos de machine learning colaborativos.

---


## 🧠 ¿Por qué Aprendizaje Federado en Shopcart?

El **aprendizaje federado** permite que múltiples usuarios (clientes de Shopcart) entrenen conjuntamente un modelo de recomendación sin necesidad de enviar sus datos al servidor central. En lugar de eso, cada cliente entrena un modelo localmente y solo envía los **pesos del modelo** para ser promediados globalmente.

Esto beneficia a Shopcart en:

- ✅ Protección de datos personales (cumple con GDPR y otras regulaciones)
- ✅ Recomendaciones personalizadas respetando la privacidad
- ✅ Mayor fidelización por confianza del usuario
- ✅ Escalabilidad y arquitectura distribuida moderna

---

## 🏛️ Arquitectura Propuesta

```text
         ┌────────────────────────────┐
         │    Interfaz Emocional      │
         │  (Shopcart Frontend App)   │
         └────────────┬───────────────┘
                      │
                      ▼
       ┌───────────────────────────────┐
       │  Nodo Cliente (dispositivo)   │
       │  - Entrena modelo local       │
       │  - Datos emocionales y UX     │
       └────────────┬──────────────────┘
                    ▼
       ┌───────────────────────────────┐
       │   Servidor de Coordinación    │
       │  - Agrega pesos (Federated)   │
       │  - Mide precisión y pérdida   │
       └────────────┬──────────────────┘
                    ▼
         ┌────────────────────────┐
         │    Almacenamiento DB   │
         │  SQLite / PostgreSQL   │
         └────────────────────────┘

## 🧱 Estructura del Proyecto

shopcart_federated_sklearn/
│
├── client_data.py # Generación de datos simulados por cliente
├── db_handler.py # Manejador de base de datos SQLite
├── federated_training.py # Lógica de entrenamiento federado
├── main.py # Script principal de ejecución
├── visualize_metrics.py # Visualización de métricas de precisión y pérdida
├── federated_results.db # Base de datos con resultados
└── venv/ # Entorno virtual de Python




---

## 🧠 Componentes del Proyecto

### `client_data.py`
```python
from sklearn.datasets import make_classification
import numpy as np

def create_client_data(num_clients=5, samples_per_client=100):
    clients = []
    for _ in range(num_clients):
        X, y = make_classification(n_samples=samples_per_client, n_features=10,
                                   n_informative=5, n_classes=2, random_state=np.random.randint(10000))
        clients.append((X, y))
    return clients


### `db_handler.py`


import sqlite3

def initialize_db():
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS metrics (
            round INTEGER,
            accuracy REAL,
            loss REAL
        )
    ''')
    conn.commit()
    conn.close()

def save_result(round_num, accuracy, loss):
    conn = sqlite3.connect("federated_results.db")
    cursor = conn.cursor()
    cursor.execute('INSERT INTO metrics (round, accuracy, loss) VALUES (?, ?, ?)', (round_num, accuracy, loss))
    conn.commit()
    conn.close()


### federated_training.py


import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, log_loss

def federated_average(models):
    avg_weights = np.mean([model.coef_ for model in models], axis=0)
    avg_intercept = np.mean([model.intercept_ for model in models], axis=0)
    return avg_weights, avg_intercept

def run_federated_training(clients, num_rounds=5):
    global_model = LogisticRegression(max_iter=1000)
    X_test, y_test = clients[0]

    for round_num in range(1, num_rounds + 1):
        local_models = []
        for X, y in clients:
            local_model = LogisticRegression(max_iter=1000)
            local_model.fit(X, y)
            local_models.append(local_model)

        avg_weights, avg_intercept = federated_average(local_models)
        global_model.coef_ = avg_weights
        global_model.intercept_ = avg_intercept

        logits = global_model.predict_proba(X_test)
        y_pred = global_model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        loss = log_loss(y_test, logits)

        yield round_num, acc, loss



### main.py


from client_data import create_client_data
from db_handler import initialize_db, save_result
from federated_training import run_federated_training

initialize_db()
clients = create_client_data()

for round_num, acc, loss in run_federated_training(clients):
    print(f"Ronda {round_num} → Acc: {acc:.3f}, Loss: {loss:.3f}")
    save_result(round_num, acc, loss)



▶️ Instrucciones de Ejecución
1. Clona el repositorio:
git clone https://github.com/tu_usuario/shopcart_federated_sklearn.git
cd shopcart_federated_sklearn

2. Crea y activa un entorno virtual (Windows):
python -m venv venv
.\venv\Scripts\activate

Si da error, ejecuta en PowerShell:
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser


3. Instala las dependencias:

pip install --upgrade pip
pip install scikit-learn numpy

4. Ejecuta el script principal:

python main.py


📊 Visualización de Métricas

pip install pandas matplotlib

### visualize_metrics.py

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

conn = sqlite3.connect("federated_results.db")
df = pd.read_sql_query("SELECT * FROM metrics ORDER BY round", conn)
conn.close()

print("\nMétricas registradas:")
print(df.to_string(index=False))

plt.figure()
plt.plot(df['round'], df['accuracy'], marker='o')
plt.title('Precisión por Ronda')
plt.xlabel('Ronda')
plt.ylabel('Precisión')
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure()
plt.plot(df['round'], df['loss'], marker='o')
plt.title('Pérdida por Ronda')
plt.xlabel('Ronda')
plt.ylabel('Pérdida')
plt.grid(True)
plt.tight_layout()
plt.show()


📈 Ejemplo de Salida

Ronda 1 → Acc: 0.920, Loss: 0.439
Ronda 2 → Acc: 0.860, Loss: 0.432
Ronda 3 → Acc: 0.900, Loss: 0.442
...

La precisión y la pérdida se visualizan también mediante gráficas de evolución por ronda.

🌱 Mejoras Futuras
Uso de datos reales o anonimización de datos de usuarios.

Integración con TensorFlow Federated.

Almacenamiento de modelos con joblib o pickle.

Dashboard visual con streamlit.

🧠 Conclusión
Este proyecto demuestra una arquitectura federada aplicada a un caso de negocio moderno (ShopCart), ofreciendo un enfoque escalable y centrado en la privacidad para el entrenamiento de modelos de inteligencia artificial.

⚙️ Requisitos Técnicos
Python 3.12

scikit-learn

numpy

pandas

matplotlib


🔗 Referencias
Scikit-learn Documentation

SQLite Python Docs

Federated Learning - Google AI Blog